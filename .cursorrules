# Agent Workflow Rules

## ìƒˆ ëŒ€í™” ì‹œì‘ ì‹œ ìë™ ìƒí™© íŒŒì•… (MANDATORY)
- **ALWAYS** ìƒˆë¡œìš´ ëŒ€í™” ì‹œì‘ ì‹œ ë‹¤ìŒ ìˆœì„œë¡œ ìë™ ì‹¤í–‰:
  1. `projects/01-todo-list/QUICK_START.md` ì½ê¸° (í•„ìˆ˜)
  2. `projects/01-todo-list/PROJECT_STATUS.md` ì½ê¸° (í•„ìˆ˜)  
  3. `projects/01-todo-list/WORK_LOG.md` ì½ê¸° (ì„ íƒì )
  4. í˜„ì¬ ë°±ì—”ë“œ ì»´íŒŒì¼ ìƒíƒœ í™•ì¸: `cd projects/01-todo-list/backend && ./gradlew compileKotlin`
  5. í¬íŠ¸ ì‚¬ìš© í˜„í™© í™•ì¸: `lsof -i :8080` (ë°±ì—”ë“œ), `lsof -i :3000` (í”„ë¡ íŠ¸ì—”ë“œ)
  6. ìƒí™© íŒŒì•… í›„ ìš°ì„ ìˆœìœ„ ì‘ì—… ìë™ ì‹œì‘

## ìë™ ìƒí™© íŒŒì•… í›„ í–‰ë™ ê·œì¹™
- ë¬¸ì„œ ì½ê¸° ì™„ë£Œ í›„ **ì¦‰ì‹œ** í˜„ì¬ ìƒí™© ìš”ì•½ ì œì‹œ
- ê°€ì¥ ìš°ì„ ìˆœìœ„ ë†’ì€ ë¬¸ì œë¶€í„° **ìë™ìœ¼ë¡œ** í•´ê²° ì‹œì‘
- ì‚¬ìš©ìì—ê²Œ ë³„ë„ ì§€ì‹œ ìš”ì²­í•˜ì§€ ë§ê³  **ëŠ¥ë™ì ìœ¼ë¡œ** ì‘ì—… ì§„í–‰
- ê° ë‹¨ê³„ë³„ ì§„í–‰ìƒí™©ì„ ì‹¤ì‹œê°„ìœ¼ë¡œ ë³´ê³ 

## File Modification Scope
- Modify only ONE file per conversation
- Complete one connected feature/logic unit only
- No cross-file dependencies in single conversation session
- Finish current file completely before moving to next file

## Code Modification Units
- One complete component implementation
- One complete custom hook implementation  
- One complete API route implementation
- One complete page implementation
- One complete utility function set

## Incremental Development Rules
- Implement code in small incremental units (methods/functions)
- Write maximum 1-2 methods or functions at a time
- Get user approval before proceeding to next unit
- Explain each small unit before implementation
- Allow user to review and approve each increment

## UI Development Rules - MANDATORY STEP-BY-STEP APPROVAL
- **NEVER implement multiple UI sections simultaneously**
- **ALWAYS wait for explicit user approval before proceeding to next UI section**
- Implement UI components ONE SECTION AT A TIME only
- Break down UI into logical sections (header, main content, footer, sidebar, etc.)
- Complete one UI section before moving to next section
- **MANDATORY**: Get user confirmation/approval for each UI section before proceeding
- **PROHIBITED**: Implementing entire page UI in single edit without step-by-step approval
- Examples of UI sections that require separate approval:
  - Header navigation only (wait for approval)
  - Main content area only (wait for approval)
  - Form fields (one group at a time, wait for approval)
  - Button groups (wait for approval)
  - Modal components (structure â†’ content â†’ actions, each step needs approval)
  - List items (template â†’ styling â†’ interactions, each step needs approval)
  - Individual form sections (title input â†’ description â†’ priority â†’ submit button)
  - Individual table/list components (header â†’ body â†’ pagination)

## UI Section Approval Process
1. **Explain** what UI section will be implemented
2. **Ask for explicit permission** before implementing
3. **Implement ONLY the approved section**
4. **Show result** and wait for feedback
5. **Ask for approval** to proceed to next section
6. **Repeat process** for each UI section

## Conversation Flow
- Check current file status before modification
- Verify completion after modification
- Confirm current work is done before next file
- Ask for explicit approval before moving to different file

## Code Update Process
- Provide theoretical explanation for each code update
- Explain the logic, patterns, and architectural decisions
- Include why specific technologies/approaches were chosen
- Wait for user acceptance before proceeding with implementation
- No code changes without prior explanation and approval

## Code Quality Guidelines
- Write all comments in Korean (í•œê¸€)
- Use descriptive Korean comments for complex logic
- Maintain consistent Korean commenting style
- Avoid mixing Korean and English in comments

## Prohibited Actions
- Simultaneous multi-file modifications
- Moving to next file with incomplete current file
- Creating long dependency chains across files
- Partial implementations that require immediate follow-up in other files
- Writing large code blocks without incremental approval
- **PROHIBITED**: Implementing multiple UI sections without step-by-step user approval
- **PROHIBITED**: Making assumptions about UI design without explicit user confirmation
- **PROHIBITED**: Starting work without reading project status documents first

## File Completion Criteria
- All functions/components are fully implemented
- No TODO comments or placeholder code
- All imports/exports are properly configured
- File is immediately runnable/testable 

## Commit Guidelines
- One commit per completed file modification
- Commit only when file meets completion criteria
- Use conventional commit format: `type(scope): description`
- Commit types: feat, fix, docs, style, refactor, test, chore
- Scope should indicate the specific file or component modified
- Description should clearly explain what was implemented
- No commits for partial or incomplete implementations
- Each commit should represent a working, testable unit
- **MANDATORY**: Commit frequently in small incremental units
- **MANDATORY**: Commit after each UI section completion
- **MANDATORY**: Commit after each bug fix or feature completion
- **MANDATORY**: Never accumulate large changes without committing
- Commit message examples:
  - `feat(todo-api): implement todo CRUD endpoints`
  - `feat(todo-form): add todo creation component`
  - `docs(readme): add project setup instructions`
  - `fix(todo-list): resolve sorting issue`
  - `fix(api): resolve dueDate format issue for todo creation`
  - `feat(ui): add todo list display section`
  - `style(header): improve responsive design`

## Push Guidelines
- **MANDATORY**: Push regularly to backup progress and enable collaboration
- **MANDATORY**: Push after every 2-3 commits maximum
- **MANDATORY**: Push after completing any significant feature or fix
- **MANDATORY**: Push at the end of each development session
- **MANDATORY**: Push before switching to different features or files
- Push triggers:
  - After UI section completion and commit
  - After bug fix completion and commit
  - After feature completion and commit
  - Before ending work session
  - Before major refactoring
  - After reaching milestone or checkpoint
- Pre-push checklist:
  - Verify all commits have meaningful messages
  - Ensure no sensitive data in commits
  - Confirm code is in working state
  - Check no large files or build artifacts included
- Push frequency examples:
  - Complete a UI component â†’ commit â†’ push
  - Fix 2-3 bugs â†’ push accumulated commits
  - Finish feature implementation â†’ push
  - End of coding session â†’ push any pending commits

## Problem Resolution Documentation
- Document all resolved issues with comprehensive analysis
- Mandatory reporting format when fixing problems:
  1. **Problem Description**: Clear description of the error/issue (include error messages, symptoms)
  2. **Root Cause Analysis**: Explain why the problem occurred
  3. **Solution Implemented**: Detail what was changed and how
  4. **Code Comparison**: Show before/after code snippets with clear diff
  5. **Verification**: Confirm the fix with test results or validation
- Include file paths and line numbers in problem reports
- Use Korean for explanations and documentation
- Create reusable knowledge base for similar future issues
- Example format:
  ```
  ## ğŸ”§ ë¬¸ì œ í•´ê²° ë³´ê³ 
  
  ### ğŸš¨ ë°œìƒí•œ ë¬¸ì œ
  - ì˜¤ë¥˜: [ì˜¤ë¥˜ ë©”ì‹œì§€ë‚˜ ì¦ìƒ]
  - íŒŒì¼: [íŒŒì¼ ê²½ë¡œ:ë¼ì¸ ë²ˆí˜¸]
  
  ### ğŸ” ì›ì¸ ë¶„ì„
  - [ì™œ ë°œìƒí–ˆëŠ”ì§€ ë¶„ì„]
  
  ### âœ… í•´ê²° ë°©ë²•
  - [ì–´ë–»ê²Œ ìˆ˜ì •í–ˆëŠ”ì§€]
  
  ### ğŸ“ ì½”ë“œ ë³€ê²½ì‚¬í•­
  - ìˆ˜ì • ì „: [ê¸°ì¡´ ì½”ë“œ]
  - ìˆ˜ì • í›„: [ìƒˆë¡œìš´ ì½”ë“œ]
  
  ### ğŸ§ª ê²€ì¦ ê²°ê³¼
  - [í…ŒìŠ¤íŠ¸ ê²°ê³¼ë‚˜ ë™ì‘ í™•ì¸]
  ``` 